---
title: "R Notebook"
output:
  html_document:
    df_print: paged
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(DBI)
library(knitr)

# connect to Game
con <- DBI::dbConnect(RSQLite::SQLite(), "Game.db")

# use the database connection for all SQL chunks in this notebook and hide the code by default
knitr::opts_chunk$set(connection = "con", echo=FALSE)
```

The overview of the tables we have used can be seen in this database model:

<img src = "images/Game.png" />

The content of each dataset is listed below:


```{sql connection=con}
SELECT *
FROM Order_List;
```

```{sql connection=con}
SELECT *
FROM Address;
```

```{sql connection=con}
SELECT *
FROM Orders;
```

```{sql connection=con}
SELECT *
FROM Parts;
```

```{sql connection=con}
SELECT *
FROM Available;
```



Given the Dataset from the business game can you:
1. Get the address corresponding to the order number 103.

```{sql connection=con}
SELECT a.name, street, city -- ol.name
FROM Address a
--INNER JOIN Order_List ol on a.name = ol.name
--WhERE number = 103;
WHERE name IN(
              SELECT name
              FROM Order_List ol
              WHERE number = 103
);

```

2. All order numbers for each city.

```{sql connection=con}
SELECT ol.number, city
FROM Address a
INNER JOIN Order_List ol on a.name = ol.name
ORDER BY city;

```

3. All parts for the order number 103.

```{sql connection=con}

SELECT Item
FROM Orders
WhERE Number = 103;

```

4. The total number of parts required.

```{sql connection=con}

SELECT SUM(Part)
FROM Parts;

```

5. Check if all parts are in the warehouse.

```{sql connection=con}


```

6. If some parts are missing, starting form 101, which order cannot be delivered. (manual)





7. Show in a graph the total number of ordered items per city.

```{sql connection=con}

```
